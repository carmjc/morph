package net.carmgate.morph.model.ship;

import java.util.ArrayList;
import java.util.List;

import net.carmgate.morph.ia.IA;
import net.carmgate.morph.model.Vect3D;
import net.carmgate.morph.model.morph.Morph;
import net.carmgate.morph.model.physics.Force;

import org.apache.log4j.Logger;

/**
 * TODO : Il faut ajouter un centre d'inertie et modifier les calculs des forces pour gérer le vrai centre d'inertie.
 */
public abstract class Ship implements Cloneable {

	private static final Logger logger = Logger.getLogger(Ship.class);

	/** The ship position in the world. */
	public Vect3D pos;
	public Vect3D posSpeed;
	public Vect3D posAccel;

	/** The ship orientation in the world. */
	public float rot;
	public float rotSpeed;
	public float rotAccel;

	/** The drag factor. The lower, the more it's dragged. */
	public float dragFactor = 0.995f;

	/** Under that speed, the ship stops completely. */
	public static final float MIN_SPEED = 0.00001f;

	/**
	 * The list of the forces attached to the ship or a constituant of the ship.
	 * This is a force generated by the ship. On the contrary external forces are applied to the ship but not generated by it.
	 * Example: the force generated by a propulsor.
	 * Mathematically, it differs from external forces in that a rotation of the ship leads to a rotation of the force.
	 */
	public List<Force> ownForceList = new ArrayList<Force>();

	/**
	 * External forces list.
	 * These forces are not generated by the ship but applied to it.
	 * Example: A contact force (collision with an other ship, or explosion)
	 */
	public List<Force> externalForceList = new ArrayList<Force>();

	/** The list of this ship's morphs. */
	private final List<Morph> morphList = new ArrayList<Morph>();

	/** The selected morph. */
	private final List<Morph> selectedMorphList = new ArrayList<Morph>();

	/** List of active morphs. */
	private final List<Morph> activeMorphList = new ArrayList<Morph>();

	/** List of ships IAs. */
	private final List<IA> iaList = new ArrayList<IA>();

	public Ship(float x, float y, float z) {
		pos = new Vect3D(x, y, z);
		posSpeed = new Vect3D(0, 0, 0);
		posAccel = new Vect3D(0, 0, 0);
		rot = 0;
		rotSpeed = 0;
		rotAccel = 0;
	}

	public void addMorph(Morph morph) {
		morph.setShip(this);
		morphList.add(morph);
	}

	public void applyForces() {
		posAccel.x = 0;
		posAccel.y = 0;
		posAccel.z = 0;
		rotAccel = 0;

		for (Force f : ownForceList) {

			// the acceleration caused by the force is applied to the ship's inertia center.
			Vect3D forceVector = new Vect3D(f.vector);
			forceVector.rotate(f.target.getRotInShip() + rot); // remove the effect of morph and ship rotation. TODO : check this
			posAccel.add(forceVector);

			// the tangential element of the force generates a rotation of the ship
			// the following is done in the ship's referential
			Vect3D targetClone = new Vect3D(f.target.getPosInShip()); //FIXME this should rather use the center of mass of the ship
			targetClone.substract(pos);

			// Get the angle between the two vectors
			float angle = targetClone.angleWith(forceVector);

			// Compute the acceleration
			rotAccel += targetClone.modulus() * forceVector.modulus() * Math.sin(Math.toRadians(angle)) / morphList.size() * 0.05f;

		}
	}

	@Override
	public Object clone() throws CloneNotSupportedException {
		Ship clone = (Ship) super.clone();

		return clone;
	}

	public List<Morph> getActiveMorphList() {
		return activeMorphList;
	}

	public List<IA> getIAList() {
		return iaList;
	}

	public List<Morph> getMorphList() {
		return morphList;
	}

	/**
	 * Get the neighbours of the provided Morph.
	 * Works in 2D only for now.
	 * @param morph
	 * @return
	 */
	public List<Morph> getNeighbours(Morph morph) {
		List<Morph> neighbours = new ArrayList<Morph>();
		//  1 2
		// 3   4
		//  5 6
		neighbours.add(getShipMorph((int) morph.shipGridPos.x -1, (int) morph.shipGridPos.y + 1, (int) morph.shipGridPos.z));
		neighbours.add(getShipMorph((int) morph.shipGridPos.x, (int) morph.shipGridPos.y + 1, (int) morph.shipGridPos.z));
		neighbours.add(getShipMorph((int) morph.shipGridPos.x - 1, (int) morph.shipGridPos.y, (int) morph.shipGridPos.z));
		neighbours.add(getShipMorph((int) morph.shipGridPos.x + 1, (int) morph.shipGridPos.y, (int) morph.shipGridPos.z));
		neighbours.add(getShipMorph((int) morph.shipGridPos.x, (int) morph.shipGridPos.y - 1, (int) morph.shipGridPos.z));
		neighbours.add(getShipMorph((int) morph.shipGridPos.x + 1, (int) morph.shipGridPos.y - 1, (int) morph.shipGridPos.z));
		return neighbours;
	}

	public List<Morph> getSelectedMorphList() {
		return selectedMorphList;
	}

	public Morph getShipMorph(int x, int y, int z) {
		for (Morph m : morphList) {
			if (m.shipGridPos.x == x && m.shipGridPos.y == y && m.shipGridPos.z == z) {
				return m;
			}
		}

		return null;
	}

	/**
	 * Looks for the {@link Morph} at the specified position in the ship.
	 * If there is no morph at the given position, it returns null.
	 * @param pos the position in the ship
	 * @return null if there is no morph at the specified location.
	 */
	public Morph getShipMorph(Vect3D pos) {
		return getShipMorph((int) pos.x, (int) pos.y, (int) pos.z);
	}

	public void removeActiveMorph(Morph morph) {
		activeMorphList.remove(morph);
	}

	public void setSelectedMorph(int index) {
		selectedMorphList.clear();
		if (index >= 0 && index < morphList.size()) {
			selectedMorphList.add(morphList.get(index));
		}
	}

	public boolean toggleActiveMorph(Morph morph) {
		if (activeMorphList.contains(morph)) {
			activeMorphList.remove(morph);
			return false;
		}

		activeMorphList.add(morph);
		return true;
	}

	public void toggleSelectedMorph(int index) {
		Morph selectedMorph = morphList.get(index);
		if (selectedMorphList.contains(selectedMorph)) {
			selectedMorphList.remove(selectedMorph);
		} else {
			selectedMorphList.add(selectedMorph);
		}
	}

	@Override
	public String toString() {
		return "ship:" + pos.toString();
	}

	public void update() {
		applyForces();

		posSpeed.x += posAccel.x;
		posSpeed.y += posAccel.y;
		posSpeed.z += posAccel.z;

		posSpeed.x = Math.abs(posSpeed.x * dragFactor) > MIN_SPEED ? posSpeed.x * dragFactor : 0;
		posSpeed.y = Math.abs(posSpeed.y * dragFactor) > MIN_SPEED ? posSpeed.y * dragFactor : 0;
		posSpeed.z = Math.abs(posSpeed.z * dragFactor) > MIN_SPEED ? posSpeed.z * dragFactor : 0;

		pos.x += posSpeed.x;
		pos.y += posSpeed.y;
		pos.z += posSpeed.z;

		rotSpeed += rotAccel;

		rotSpeed = Math.abs(rotSpeed * dragFactor) > MIN_SPEED ? rotSpeed * dragFactor : 0;

		rot = (rot + rotSpeed) % 360;

		updateMorphs();
	}

	private void updateMorphs() {
		for (Morph m : morphList) {
			// Position of the morph in the referential centered on the ship (the central one has coords (0, 0).
//			m.getPosInShip().x = m.shipGridPos.x * World.GRID_SIZE + m.shipGridPos.y * World.GRID_SIZE / 2;
//			m.getPosInShip().y = (float) (m.shipGridPos.y * World.GRID_SIZE * Math.sqrt(3)/2);

			// Adding the rotation around the center of the ship
//			m.getPosInShip().rotate(rot);

			// Adding the position of the ship's inertia center
//			m.getPosInShip().add(pos);

			// Disabling if necessary
			if (m.mass < m.disableMass && !m.disabled) {
				logger.debug("Disabling morph");
				m.disabled = true;
			}

			// Reenable the morph if possible
			if (m.mass >= m.reenableMass && m.disabled && m.energy > 0) {
				m.disabled = false;
			}

			// Regaining mass if disabled
			if (m.disabled && m.mass < m.maxMass) {
				m.mass += 0.1;
			}
		}
	}
}
